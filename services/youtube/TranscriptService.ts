import { ITranscriptService } from '../interfaces/ITranscriptService';
import { TranscriptSegment, TranscriptOptions, RapidAPIResponse } from '@/types/transcript';
import { TranscriptError } from '@/types/errors';
import { YoutubeTranscript } from 'youtube-transcript';

export class TranscriptService implements ITranscriptService {
    private readonly MAX_RETRIES = 3;
    private readonly RETRY_DELAY = 1000;
    private readonly isProduction = process.env.NODE_ENV === 'production';
    private readonly rapidApiKey = process.env.RAPID_API_KEY;

    public async fetchTranscript(
        videoId: string,
        options?: TranscriptOptions
    ): Promise<TranscriptSegment[]> {
        let lastError: Error | null = null;

        // Different fetch configurations to try
        const attempts = [
            () => this.fetchWithConfig(videoId, options),
            () => this.fetchWithConfig(videoId, { ...options, autoGenerated: true }),
            () => this.fetchWithConfig(videoId, { ...options, language: 'en' }),
            () => this.fetchWithConfig(videoId, {
                ...options,
                language: 'en',
                autoGenerated: true
            }),
        ];

        for (const attempt of attempts) {
            try {
                return await attempt();
            } catch (error) {
                lastError = error as Error;
                continue;
            }
        }

        throw new TranscriptError(
            lastError?.message || 'Failed to fetch transcript after all attempts'
        );
    }

    public async getRawTranscript(videoId: string): Promise<string> {
        if (this.isProduction && this.rapidApiKey) {
            return this.getRapidAPITranscript(videoId);
        }

        // Fallback to local method
        const transcript = await this.fetchTranscript(videoId);
        return transcript.map(segment => segment.text).join(' ');
    }

    private async getRapidAPITranscript(videoId: string): Promise<string> {
        try {
            const response = await fetch('https://video-transcript-scraper.p.rapidapi.com/', {
                method: 'POST',
                headers: {
                    'x-rapidapi-key': this.rapidApiKey!,
                    'x-rapidapi-host': 'video-transcript-scraper.p.rapidapi.com',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    video_url: `https://youtu.be/${videoId}`,
                    language: 'en'
                })
            });

            if (!response.ok) {
                throw new Error(`RapidAPI request failed: ${response.statusText}`);
            }

            const data: RapidAPIResponse = await response.json();

            // Return the full text if available, otherwise try to join transcript segments
            return data.text || (data.transcript?.map(segment => segment.text).join(' ') ?? '');
        } catch (error) {
            console.error('RapidAPI transcript fetch failed:', error);

            // If RapidAPI fails in production, try the local method as fallback
            try {
                const transcript = await this.fetchTranscript(videoId);
                return transcript.map(segment => segment.text).join(' ');
            } catch (fallbackError) {
                throw new TranscriptError(
                    `Failed to fetch transcript: ${(error as Error).message}`
                );
            }
        }
    }

    private async fetchWithConfig(
        videoId: string,
        options?: TranscriptOptions
    ): Promise<TranscriptSegment[]> {
        for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
            try {
                const config: any = {};
                if (options?.language) config.lang = options.language;
                if (options?.autoGenerated) config.auto = true;

                const transcript = await YoutubeTranscript.fetchTranscript(videoId, config);
                return transcript.map(entry => ({
                    text: entry.text,
                    duration: entry.duration,
                    offset: entry.offset
                }));
            } catch (error) {
                if (attempt === this.MAX_RETRIES) throw error;
                await new Promise(resolve =>
                    setTimeout(resolve, this.RETRY_DELAY * attempt)
                );
            }
        }

        throw new TranscriptError('Failed to fetch transcript');
    }
} 